<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crowd Canvas Component</title>
    <script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.5/gsap.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #ffffff;
        }

        .demo-spacer {
            height: 50vh;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            font-weight: 300;
            color: #ccc;
        }
    </style>
</head>
<body>
    <div class="demo-spacer">Content Above</div>
    
    <div id="crowd-canvas-root"></div>

    <div class="demo-spacer">Content Below</div>

    <script type="text/babel">
        const { useEffect, useRef } = React;

        const CrowdCanvas = ({ src = 'images/image.png', rows = 15, cols = 7 }) => {
            const canvasRef = useRef(null);

            useEffect(() => {
                const canvas = canvasRef.current;
                if (!canvas) return;

                const ctx = canvas.getContext("2d");
                if (!ctx) return;

                const config = { src, rows, cols };

                // UTILS
                const randomRange = (min, max) => min + Math.random() * (max - min);
                const randomIndex = (array) => randomRange(0, array.length) | 0;
                const removeFromArray = (array, i) => array.splice(i, 1)[0];
                const removeItemFromArray = (array, item) => removeFromArray(array, array.indexOf(item));
                const removeRandomFromArray = (array) => removeFromArray(array, randomIndex(array));
                const getRandomFromArray = (array) => array[randomIndex(array) | 0];

                // TWEEN FACTORIES
                const resetPeep = ({ stage, peep }) => {
                    const direction = Math.random() > 0.5 ? 1 : -1;
                    const offsetY = 100 - 250 * gsap.parseEase("power2.in")(Math.random());
                    const startY = stage.height - peep.height + offsetY;
                    let startX, endX;

                    if (direction === 1) {
                        startX = -peep.width;
                        endX = stage.width;
                        peep.scaleX = 1;
                    } else {
                        startX = stage.width + peep.width;
                        endX = 0;
                        peep.scaleX = -1;
                    }

                    peep.x = startX;
                    peep.y = startY;
                    peep.anchorY = startY;

                    return { startX, startY, endX };
                };

                const normalWalk = ({ peep, props }) => {
                    const { startX, startY, endX } = props;
                    const xDuration = 10;
                    const yDuration = 0.25;

                    const tl = gsap.timeline();
                    tl.timeScale(randomRange(0.5, 1.5));
                    tl.to(peep, { duration: xDuration, x: endX, ease: "none" }, 0);
                    tl.to(peep, { duration: yDuration, repeat: xDuration / yDuration, yoyo: true, y: startY - 10 }, 0);

                    return tl;
                };

                const walks = [normalWalk];

                // FACTORY FUNCTIONS
                const createPeep = ({ image, rect }) => {
                    const peep = {
                        image,
                        rect: [],
                        width: 0,
                        height: 0,
                        drawArgs: [],
                        x: 0,
                        y: 0,
                        anchorY: 0,
                        scaleX: 1,
                        walk: null,
                        setRect: (rect) => {
                            peep.rect = rect;
                            peep.width = rect[2];
                            peep.height = rect[3];
                            peep.drawArgs = [peep.image, ...rect, 0, 0, peep.width, peep.height];
                        },
                        render: (ctx) => {
                            ctx.save();
                            ctx.translate(peep.x, peep.y);
                            ctx.scale(peep.scaleX, 1);
                            ctx.drawImage(peep.image, peep.rect[0], peep.rect[1], peep.rect[2], peep.rect[3], 0, 0, peep.width, peep.height);
                            ctx.restore();
                        },
                    };

                    peep.setRect(rect);
                    return peep;
                };

                // MAIN
                const img = document.createElement("img");
                const stage = { width: 0, height: 0 };
                const allPeeps = [];
                const availablePeeps = [];
                const crowd = [];

                const createPeeps = () => {
                    const { rows, cols } = config;
                    const { naturalWidth: width, naturalHeight: height } = img;
                    const total = rows * cols;
                    const rectWidth = width / rows;
                    const rectHeight = height / cols;

                    for (let i = 0; i < total; i++) {
                        allPeeps.push(
                            createPeep({
                                image: img,
                                rect: [
                                    (i % rows) * rectWidth,
                                    ((i / rows) | 0) * rectHeight,
                                    rectWidth,
                                    rectHeight,
                                ],
                            })
                        );
                    }
                };

                const initCrowd = () => {
                    while (availablePeeps.length) {
                        addPeepToCrowd().walk.progress(Math.random());
                    }
                };

                const addPeepToCrowd = () => {
                    const peep = removeRandomFromArray(availablePeeps);
                    const walk = getRandomFromArray(walks)({
                        peep,
                        props: resetPeep({ peep, stage }),
                    }).eventCallback("onComplete", () => {
                        removePeepFromCrowd(peep);
                        addPeepToCrowd();
                    });

                    peep.walk = walk;
                    crowd.push(peep);
                    crowd.sort((a, b) => a.anchorY - b.anchorY);

                    return peep;
                };

                const removePeepFromCrowd = (peep) => {
                    removeItemFromArray(crowd, peep);
                    availablePeeps.push(peep);
                };

                const render = () => {
                    if (!canvas) return;
                    ctx.clearRect(0, 0, canvas.width, canvas.height);
                    ctx.save();
                    ctx.scale(devicePixelRatio, devicePixelRatio);

                    crowd.forEach((peep) => {
                        peep.render(ctx);
                    });

                    ctx.restore();
                };

                const resize = () => {
                    if (!canvas) return;
                    stage.width = canvas.clientWidth;
                    stage.height = canvas.clientHeight;
                    canvas.width = stage.width * devicePixelRatio;
                    canvas.height = stage.height * devicePixelRatio;

                    crowd.forEach((peep) => {
                        peep.walk.kill();
                    });

                    crowd.length = 0;
                    availablePeeps.length = 0;
                    availablePeeps.push(...allPeeps);

                    initCrowd();
                };

                const init = () => {
                    createPeeps();
                    resize();
                    gsap.ticker.add(render);
                };

                img.onload = init;
                img.src = config.src;

                const handleResize = () => resize();
                window.addEventListener("resize", handleResize);

                return () => {
                    window.removeEventListener("resize", handleResize);
                    gsap.ticker.remove(render);
                    crowd.forEach((peep) => {
                        if (peep.walk) peep.walk.kill();
                    });
                };
            }, [src, rows, cols]);

            return React.createElement("canvas", {
                ref: canvasRef,
                style: {
                    position: 'absolute',
                    bottom: 0,
                    height: '90vh',
                    width: '100%'
                }
            });
        };

        const Skiper39 = () => {
            return React.createElement("div", {
                style: {
                    position: 'relative',
                    height: '100vh',
                    width: '100%',
                    background: 'white',
                    color: 'black'
                }
            },
                React.createElement("div", {
                    style: {
                        position: 'absolute',
                        top: '5.5rem',
                        left: '50%',
                        transform: 'translateX(-50%)',
                        display: 'grid',
                        alignContent: 'start',
                        justifyItems: 'center',
                        gap: '1.5rem',
                        textAlign: 'center',
                        color: 'black'
                    }
                },
                    React.createElement("span", {
                        style: {
                            position: 'relative',
                            maxWidth: '12ch',
                            fontSize: '0.75rem',
                            textTransform: 'uppercase',
                            lineHeight: '1.3',
                            opacity: 0.4,
                            letterSpacing: '0.05em'
                        }
                    }, "Crowd Canvas")
                ),
                React.createElement("div", {
                    style: {
                        position: 'absolute',
                        bottom: 0,
                        height: '100%',
                        width: '100vw'
                    }
                },
                    React.createElement(CrowdCanvas, {
                        src: "/images/peeps/all-peeps.png",
                        rows: 15,
                        cols: 7
                    })
                )
            );
        };

        // Render the component
        const root = ReactDOM.createRoot(document.getElementById('crowd-canvas-root'));
        root.render(React.createElement(Skiper39));
    </script>
</body>
</html>